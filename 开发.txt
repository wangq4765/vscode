

TODO 前端

ConnectionInfo定义的变量看成全局变量

先按f1再按ctrl，不是ctrl+f1(不然没有反应)

贴合消息里定义了变量，空的没问题(底层)，sensor不行

vs debug出现错误：把出错的那一行注释掉(点击时.Design.cs自动创建的)

LotService/ProductService/MachineService/DurableService/FactoryService是API

没有View查询按钮就复制grdproduct到.cs文件中搜索，这是逆向查找(Service在txtLotName_keyup中)

grdMachineRecipeHeader.AddGridColumn("DESCIRPTION", "Description", 90, Infragistics.Win.HAlign.Left, true);
此字段查不到数据：DESCIRPTION改成DESCRIPTION

点击查询按钮后不仅grid没有数据，就连headerCaption都消失了
分析：bscustomquery→CLOB中的sql有错误

The operation could not be completed.另一个程序正在使用此文件，进程无法访问ENIG.Shell.vshost.exe
解决：任务管理器→详细信息→关闭SNS.Shell.vshost.exe/ENIG.Shell.vshost.exe(大不了多运行几次)

跨项目复制粘贴：.Designer.cs和.cs两个文件此行代码修改就可以了
namespace MES.Module.Views.Material

this.grdReworkFlow.Rows[0].Activated = true;
this.grdReworkFlow.Rows[0].Selected = true;
// 上面两行代码自动激活下面的函数
private void grdReworkFlow_AfterRowActivate(object sender, EventArgs e)

// 加了一个!导致调试的时候直接到了}，直接跳过中间的许多行代码
if (String.IsNullOrEmpty(machineInfoView1.comPortID.Text))
{
    return;
}

// PTMS界面输入密码登录不进去
<DaemonList>
    <Daemon>tcp:10.73.7.68:7500</Daemon>
</DaemonList>
// 上面是测试用的，下面是正确的
<DaemonList>
    <Daemon></Daemon>
</DaemonList>
// 这是一个 XML 格式的文件，其中包含了一个名为 DaemonList 的标签，里面有一个名为 Daemon 的子标签，并且它的值为 "tcp:10.73.7.68:7500"，这可能是一个网络地址或端口号。





感叹号：出现了冲突
一红一黄：仅修改了一个文件
问号：该项目目录中不存在它可能已经被移动、重命名或者删除

MES.Common→Controls：定义原始控件的类
MES.Common→Entities：传输的字段(sql表字段)
MES.Common→Util：定义工具的类
MES.Common→Image/MenuIcon/Resources/FunctionIcon：图片

MES.Common→IDMConst.cs：定义常量
MES.Common→ConnectionInfo.cs：定义常量
MES.Common→UDFCONST.cs：定义常量
MES.Common→UILogger.cs：catch中的Trace
MES.Common→BaseForm.cs/ChildForm.cs：基础窗体
MES.Common→ContinueMsgBox.cs/ExceptionMsgBox.cs：继续/异常消息框

MES.Module.Views.UserControls：都是被定义的"小窗体"，里面有许多控件(只能使用，不能修改)
PS："小窗体"中的KeyUp事件用GetXXInfo来补充Text控件的信息(使用类似GetPTMaterialInfo的函数)
MES.Module.Views.UserControls.LotInfoView40
MES.Module.Views.UserControls.MachineInfoView9

MES.Common.TIB：TIBCO通信
MES.Module.Services：定义服务的类
MES.Shell：配置





-----------设置-------------




vs 底部显示局部变量的窗口 打开？
之前不小心把vs底部的局部变量窗口关掉了。一直找不到。
方法：先把项目运行起来，调试状态下，点开"调试"->"窗口"，就能看到局部变量窗口了。

VS2013 断点窗口怎么调出来？
哪里需要断点就鼠标点哪里
点击红色圈圈位置
需要所有的窗口就CTRL+ALT+B
菜单-调试-窗口-断点

Visual Studio 快速定位文件位置的方法
用idea有一个瞄准的符号可以快速定位文件位置，Visual Studio没有这个但是有替代方案
工具-选项--项目和解决方案--常规--在解决方案资源管理器中跟踪活动项
tools-options-Projects and Solutions-Track Active Item in SOlution Exploer
勾选后就可以了
PS：MyEclipse有“Link with Editor”，而vscode则自带




-----选中某个词后，单击右键的查看定义、转到定义、转到声明、查找所有引用功能都非常实用(vs的快捷键和vscode非常相似)-----

跳转到指定行号：Ctrl + G

使用Tab增加缩进，Shift+Tab减少缩进

删除光标前的某个单词内的所有字符：Ctrl+BackSpace(整体地删除单词)

复制光标所在行的代码，并在下面一行生成：Ctrl+E，V(新版，这个蛮有用的)

调用智能提示(输入联想)：Ctrl + J 或Alt + →
强制智能感知****显示参数信息： Ctrl+空格

返回上一视图：Ctrl + -
返回下一视图：Ctrl + Shift + -

Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了)
Alt+↑ 当前行和上面一行交互位置(同上)

将选中的全部变小写：Ctrl + U
将选中的全部变大写：Ctrl + Shift + U

行编辑，当光标停在某一行(不用选中该行)：
复制整行：Ctrl + C
剪切整行：Ctrl + X
粘贴整行：Ctrl + V
删除整行：Ctrl + L

Visual Studio中关闭当前窗口的快捷键是什么？
比如，我现在打开了多个查看代码窗口，想关闭当前窗口，使用什么快捷键？
CTRL + F4关闭文档窗口

跳转到定义处：F12(引用和f12互补)
跳转到下一个Error或Warning：当有多个错误时可以按F8逐个跳转
重命名：比如要修改一个方法名，可以选中后按F2，输入新的名字，回车，会发现所有的文件都修改过了

VS 2017在某一次更新之后，默认设置了Ctrl+单击会跳转到定义
f12就可以跳转到定义了
source insight、vscode、qtcreator都是Ctrl+鼠标点击，用习惯Ctrl+鼠标点击，而且F12键相对左手来说太远了
果然习惯了按Ctrl之后全选变量，变成跳转到定义就很难受

VS设置断点等调试技巧
f5：开始调试/跳转到下一断点(自动跳到下一个断点处，只有一个断点则执行到底)
shift+f5：停止调试
f9：添加/删除断点
f10：逐过程(快，不会进入函数)
f11：逐语句(慢，进入调用的函数)
shift+f11：跳出当前函数(与f11相反的功能)
左边黄色的箭头可以向上拉：表示语句执行到这里了(复现问题)



匹配括号：当代码很长时，将光标置于括号旁，使用Ctrl + ]可以快速定位与当前括号相匹配的另一个括号(回退可以使用两次)

Visual Studio 找到匹配括号问题
在使用vs时有时大括号内的代码比较长，这时想要找到匹配的反括号时可以使用：
“Ctrl+}”（光标会跳转到反括号）。
此方法适用于[ ] , ( ) , { } , “ ” 。



VS转到定义与返回
在VS中按F12可以转到定义，按Ctrl+- 可以返回(直接从定义转到引用处则点击“引用”)

VS2010中跳转到此函数实现的快捷键？
该快捷键是F12
不常用根本想不到吧
跟eclipse的设计风格很不同啊
类似于eclipse中的按住ctrl然后单击  跳转到该实现函数
PS：vscode两种都可以

vs 中怎么查看一个方法被哪些方法调用过？
点击方法左上角的"1个引用"最方便(和f12跳转方向相反)
把光标移到方法上,按Shift+F12(ctrl+k+r)
把光标放在方法上，右键，"Find All References"
放到方法名那里，右键 查找所有引用

14.快速转到字段或者函数的定义处：F12
15.查找字段或者函数的所有引用：Ctrl+K+R 或者 Shift+F12
16.速览定义：光标放在字段或者函数上，按Alt+F12，调出一个窗口，查看定义或者引用，好处是：字段或函数存在多个脚本引用，不用去打开各个脚本，直接在该字段或者函数下开启一个临时窗口进行速览，按ESC退出。



-----------下面快捷键的K是key的意思-------------

格式化部分代码：Ctrl + K + F
格式化当前文档代码：Ctrl + K + D

vs如何快速批量注释，就是全部加上//的？
注释：Ctrl + K + C(C：comment)
取消注释：Ctrl + K + U(U：uncomment)

书签的作用：便于在不同程序文件之间切换
添加/删除书签：Ctrl +K + K
上一书签：Ctrl +K + P(P = positive)
下一书签：Ctrl +K + N(N = negative)

visual studio——快速折叠所有代码和展开所有代码
Ctrl + M + O：折叠所有方法
Ctrl + M+ M：折叠/展开当前方法
Ctrl + M + L：展开所有方法
折叠任意连续代码段（折叠≠注释，依然会执行）
#pragma region 折叠name
......
#pragma endregion 折叠注释
显示效果为：折叠name 折叠注释




FIXME 前端代码


obj(RECIPE)→where(CLOB)→Collection<RECIPE>(GetXXList)→SetGridColumnHeaders(AddGridColumn)--收不到数据需要从三个方面检查
--可以在MES.Common→Entities→XX.cs中增加字段(GetXXList会返回更多的字段)

public Collection<RECIPE> GetRecipeList5(object objPara, string version)
string response = msgUtil.SendQueryMessage("GetRecipeList", version, objPara, true);
// 上下等价，隐藏version=00001这个细节
public Collection<RECIPE> GetRecipeListHistory(object objPara)
string response = msgUtil.SendQueryMessage("GetRecipeListHistory", "00001", objPara, true);

// 修改数据库操作，没有的字段就加上
CONSUMABLESPEC obj = new CONSUMABLESPEC();
// CONSUMABLESPEC的路径是MES.Common→Entities→CONSUMABLESPEC.cs
Collection<CONSUMABLESPEC> colPara = new Collection<CONSUMABLESPEC>();
// INSPECTFLAG是CONSUMABLESPEC.cs中的一个变量(后端会将此变量作为判断条件)
obj.INSPECTFLAG = "LocationImport";
// 将INSPECTFLAG作为消息体的一部分传输到后端
if (factoryService.SetEvent("MDCManagementSpec", obj, colPara))

// 上下可以对比观察

--收不到数据需要在lot.cs文件中添加
/// <summary>
/// Gets or sets the LOTNAME value.
/// </summary>
private string revisioncode;
public virtual string REVISIONCODE
{
    get { return revisioncode; }
    set { revisioncode = value; }
}

// 获取输入框变量spec再赋给CLOB中的变量spec(命名一样)
TPFOPOLICY Pallet = new TPFOPOLICY();
Pallet.PRODUCTSPECNAME = txtPalletId.Text;
Collection<TPFOPOLICY> palletInfo = factoryService.GetTPFOPolicyList(Pallet, "00003");
// 上下等价，写法不同
Collection<PRODUCTSPEC> productSpecList = factoryService.GetProductSpecList(
    new PRODUCTSPEC() { FACTORYNAME = ConnectionInfo.FactoryName }, "30001");
dsDenseBoxList.DataSource = palletInfo;
grdDenseBoxList.SetPerformAutoResize();
--上面是查询数据，下面是修改数据
machineService.SetEvent("BindMachine", obj, colPara)
// 上下等价，写法不同
machineService.SetEvent(UDFCONST.BindMachine, obj, colPara)
// 上下等价，写法不同
durableService.SetEventV2(UDFCONST.ChangeCarrierLotInfoFlag,
new DURABLE()
{
    DURABLENAME = this.grdCarrierList.ActiveRow.Cells["DURABLENAME"].Text,
    LOTINFOSENDFLAG = this.cmbFlag.Text
},
null)
// 下面的代码是化金的
dsProductList.DataSource = queryService.GetQueryList<PRODUCT>
    (new PRODUCT() { PALLETNAME = row.Cells["PROCESSGROUPNAME"].Text }, "GetENIGPanelListFromSNS", "00001");

// 函数GetTPFOPolicyList从SELECT(CLOB)搜索的结果中选取类TPFOPOLICY中的数据返回到SetInitGridHeader函数展示的变量中
public Collection<CONSUMABLESPEC> MDCManeagementList(CONSUMABLESPEC obj, string version)
// MDCManeagementList和函数名一样
string replyMessage = msgUtil.SendQueryMessage("MDCManeagementList", version, obj, true);

string replyMessage = msgUtil.SendMessage(eventName, objPara, objColPara, true);
// 上面函数调用下面函数
SendMessage(messageName, objPara, objColPara, null, null, requestFlag);

XmlNodeList list = msgUtil.GetBodyChildNodeList("DATALIST", xDoc);
// 上面是DATALIST，下面是ProductSpec
XmlNodeList list = msgUtil.GetBodyChildNodeList("ProductSpec", xmlDoc);

foreach (XmlNode node in list)
{
    CONSUMABLESPEC objProduct = new CONSUMABLESPEC();

    // Parse Recived List Message：解析接收列表消息
    msgUtil.ParseRecivedListMessage(node, objProduct);

    colProductList.Add(objProduct);
}

// 前端的xDoc对应后端的message
public bool SetEvent(string eventName, object objPara, object objColPara, bool ErrorMsg)
{
    try
    {
        string replyMessage = msgUtil.SendMessage(eventName, objPara, objColPara, true);

        if (replyMessage == "")
            return false;

        XmlDocument xDoc = new XmlDocument();
        xDoc.LoadXml(replyMessage);

        if (!msgUtil.CheckErrorMessage(xDoc, ErrorMsg))
            return false;

        return true;
    }
}

--GetPOSReceiveProductSpecList：获取POSReceiveProductSpec(sql表)的列表
--在FactoryService/LotService/MachineService/DurableService中直接搜索返回的表名(RECIPE)，不区分大小写(MES.Module.Services→Services)
--SELECT * FROM BSCUSTOMQUERY WHERE QUERYID like '%TPFOPolicy%';
--SELECT * FROM BSCUSTOMQUERY WHERE QUERYID = 'GetTPFOPolicyList' AND VERSION = '00003' 
/* GetTPFOPolicyList [00003] */
--GetProductSpecInfo返回的是PRODUCTSPEC(一行记录，多用于展示框)
--GetProductSpecList返回的是Collection<PRODUCTSPEC>(多行记录，多用于网格)
--GetTPFOPolicyList返回已定义的字段(CLOB中select查询到的有值，没查无值)
--SetInitGridHeader获取GetTPFOPolicyList返回的字段(有变量才能展示返回的字段)
SELECT TP.FACTORYNAME,
       TP.PRODUCTSPECNAME,
       TP.PROCESSFLOWNAME,
       TP.PROCESSOPERATIONNAME,
       PO.CONDITIONID,
       PO.MACHINENAME,
       PO.PRIORITY,
       PO.TEST
FROM TPFOPOLICY TP, POSMACHINE PO
--:PRODUCTSPECNAME是上述对象Pallet的属性
WHERE TP.CONDITIONID=PO.CONDITIONID
AND TP.PRODUCTSPECNAME=:PRODUCTSPECNAME

--GetTPFOPolicyList函数返回字段到SetInitGridHeader函数展示的变量中
private void SetGridColumnHeaders()
{
    GridHeaders denseBoxHeads = new GridHeaders();
    denseBoxHeads.AddGridColumn("FACTORYNAME", "FactoryName", 130, Infragistics.Win.HAlign.Center, true);
    denseBoxHeads.AddGridColumn("PRODUCTSPECNAME", "ProductSpecName", 120, Infragistics.Win.HAlign.Center, true);
    denseBoxHeads.AddGridColumn("PROCESSFLOWNAME", "ProcessFlowName", 130, Infragistics.Win.HAlign.Center, true);
    denseBoxHeads.AddGridColumn("PROCESSOPERATIONNAME", "ProcessOperationName", 170, Infragistics.Win.HAlign.Center, true);
    denseBoxHeads.AddGridColumn("CONDITIONID", "ConditionId", 170, Infragistics.Win.HAlign.Center, true);
    denseBoxHeads.AddGridColumn("MACHINENAME", "MachineName", 170, Infragistics.Win.HAlign.Center, true);
    denseBoxHeads.AddGridColumn("PRIORITY", "Priority", 170, Infragistics.Win.HAlign.Center, true);
    denseBoxHeads.AddGridColumn("TEST", "Test", 170, Infragistics.Win.HAlign.Center, true);

    grdDenseBoxList.SetColumns(denseBoxHeads);
    grdDenseBoxList.SetPerformAutoResize();
}

无法将类型为“System.Collections.ObjectModel.Collection`1[MES.Common.Entities.CONSUMABLESPEC]”的对象强制转换为类型“System.Collections.ObjectModel.Collection`1[MES.Common.Entities.CONSUMABLE]”。
// 断点调试到此处出现错误
else if (objType.FullName.IndexOf("MES.Common.Entities.CONSUMABLE") > 0)
{
    CreateMessageBodyCONSUMABLE(objColPara, writer);
}
解决方法：CONSUMABLESPEC应该放在CONSUMABLE前面(长的放在前面)
else if (objType.FullName.IndexOf("MES.Common.Entities.CONSUMABLESPEC") > 0)
{
    CreateMessageBodyCONSUMABLESPEC(objColPara, writer);
}
else if (objType.FullName.IndexOf("MES.Common.Entities.CONSUMABLE") > 0)
{
    CreateMessageBodyCONSUMABLE(objColPara, writer);
}



TODO 后端

后端基于spring-osgi

贴合后端代码和SNS后端代码不一样

vs没有完全汉化，eclipse没有汉化
居然看到了汉化的eclipse...

重点：代码就是图，图就是代码
java代码和xml数据结合起来看
C#代码和OIC界面结合起来看







OIC→VS(消息体)→Eclipse(拆包)→Plsql→Eclipse(封包)→VS(消息体)→OIC

eclipse中的项目不能全部revert(配置也还原了)，vs可以(修改配置configlocal.xml)

eclipse的项目上出现红叉(是编译的问题)：Project→Clean→点击OK(Clean all projects+Build the entire workspace)
Eclipse项目没错误但有红叉(反复修改配置导致的错误)：重新down代码

激活eclipse新添加的代码：在弹窗中点击Restart(代码少的情况自动生效)
PS：线程假死需要Terminate(CNX/CNM/QRY)+Remove Launch(删除当前的面板)+Resume(继续)
激活vs新添加的代码：停止调试+重新生成解决方案(调试的时候可以修改代码但无法生效，不能修改控件)
PS：eclipse中有Build Automatically所以不需要停止调试再重新编译(eclipse每次保存都自动编译)
---build automatically 是指你的java代码改了后，eclipse会自动把改过的java代码编译成class






IDMFrame.extend.Infra
IDMFrame.extend.logger
IDMFrame.extend.workflow
IDMFrame.extend.formatter

MESSolution.Generic
MESSolution.Fmc.Service
MESSolution.Extended.Object
MESSolution.Extended.Service
MESSolution.UserProfile.Service
MESSolution.transportJob.Service

MESSolution.Lot.Service
MESSolution.Port.Service
MESSolution.Query.Service
MESSolution.Alarm.Service
MESSolution.Durable.Service
MESSolution.Product.Service
MESSolution.Machine.Service
MESSolution.Material.Service
MESSolution.Consumable.Service
MESSolution.ProcessGroup.Service
MESSolution.ProductRequest.Service










IDMMESData
src：变量lot/product/processoperationspec
Plug-in Dependencies：IDMFramework.Service.jar

--对比前端的MES.Common→Entities→DURABLELIST.cs

IDMMESData→src→com.cim.idm.mesextend.generic.util→EventInfoUtil.java：数据类型EventInfo

IDMMESData→src→com.cim.idm.mespackage.lot.management.data→Lot.java：表lot数据
IDMMESData→src→com.cim.idm.mespackage.lot.management.data→LotKey.java：表LotKey数据

IDMMESData→src→com.cim.idm.mespackage.product.management.data→Product.java：表product数据
IDMMESData→src→com.cim.idm.mespackage.processoperationspec.management.data→ProcessOperationSpec.java：表processoperationspec数据

IDMMESData→src→com.cim.idm.mespackage.durable.management.data→Durable.java：表durable数据
Durable cstData = DurableServiceProxy.getDurableService().selectByKey(new DurableKey(lotData.getCarrierName()));

--Element.class/String.class：相当于前端的Entities
--下面的.class文件不在文件夹IDMMESData中(都是jar中的代码)
MESSolution.Lot.Service→IDMFramework.Service.jar→com.cim.idm.framework.data→EventInfo.class
MESSolution.Lot.Service→IDMMES.Service.jar→com.cim.idm.mespackage.product.management.info.ext→ProductU.class
MESSolution.Generic→Plug-in Dependencies→IDMMES.Service.jar→com.cim.mespackage.durable.management.info→SetEventInfo.class








--MES.Env下面的文件夹
builders：打包上传(upload)
cfg(configuration)：配置(.ini文件)
cmd：脚本(.sh文件)
bpels：业务流程图
messages：消息体

MES.Env是操作(bpel)，其他文件夹都是Service(java文件) --bpel调用其他java文件的函数
1、MESSolution.Lot.Service
2、MESSolution.Product.Service

--MES.Env→config→bpels→CNMsvr(收发消息)
dispatching.bpel(MES.Env/config/bpels/CNMsvr/dispatching.bpel)：case决定调用那个service，service再调用那个bpel
RequestUnixProcessState.bpel：
StopAutoReadBpel.bpel：停止自动读取bpel
TerminateAfterManagement.bpel：管理后终止

--MES.Env→config→bpels→FMC
ChangeAlarmState.tsnd：更改报警状态
CreateIssueAlarm.tsnd：创建问题报警

--MES.Env→config→bpels→IFEsvr
FGMSStockInReport.tsnd：FGMS库存报告
ReceivePalletFromFGMS.tsnd：从FGMS接收打拍
RTReceivePalletFromFGMS.tsnd：返回从FGMS接收打拍

--MES.Env→messages(消息体)→TM1→CNX          -----console中的xml都是.tsnd生成的
CancelCreateCarrier.tsnd：取消创建卡夹
ChangePanelGrade.tsnd：更改面板等级
ReceiveOEMFromFGMS.tsnd：接收FGMS的OEM
ReleaseHoldLot.tsnd：释放被Hold的Lot










Program arguments：
-os ${target.os} -ws ${target.ws} -arch ${target.arch} -nl ${target.nl} -console

VM arguments：
-Declipse.ignoreApp=true
-Dosgi.noShutdown=true
-DLogDir=${workspace_loc}\logs
-Dlocation=BOE
-Dfactory=TM1
-Dcim=MES
-DworkerWeight=2
-DworkerTasks=1
-DschedulerWeight=10
-Dmode=DEVqiannan
-DREMOTE_DAEMON=
-Didmframe.serviceLookupTimeout=5000
-Dshop=SNS
-Dlamshop=LAM
-Dsvr=CNXsvr
-DSeq=CNXsvr1
-Ddq=${system_property:user.name}
-Dsmtp.hostname=mail.boe.com.cn
-Dsmtp.port=25
-Dlog4j.watchDelay=60000 
-Dlog4j.configuration="file:///${workspace_loc}\MES.Env\config\log\log4j.xml"
-DconfigRootPath=${workspace_loc}\MES.Env\config
-Didmframe.flow.bpelj=http://bpel.boe.com/bpelj/






-----------设置-------------

eclipse 中如何取消断点？
如果在代码中有断点，加载项目启动服务时，会在断点处提示有断点。而且有时候不止一个，我们就需要一个一个的跳过。对于新人来讲 有时候会不知道怎么办？
第一种方法：我们可以点击windows---->ShowView即可找到BreakingPionts双击即可。   
第二种方法：如果在ShowView中没有找到BreakingPionts我们可以点击windows---->ShowView----->other---->debug------>breakingPionts.也是可以的。

eclipse在debug模式下如何查看某变量的值？
当代码运行到某一行的时候右键本行或者上面的变量，inspect(ctrl+shift+I)。或者直接将鼠标移动到变量上也可以看到变量的值(和vs一样)。
PS：xml格式无法在eclipse中悬浮显示(vs可以显示xml格式)

eclipse 调试的查看变量的窗口怎么找出来？
点击 eclipse 工具栏的 window==>show View ==>Other
找到DEBUG 点击开 有一个Variables 这个就是调试的时候的变量显示窗口(所有的变量)

eclipse中查看错误或者警告的窗口不见了，怎么找到啊？
你好：在eclipse中的工具栏选择window--->show view--->Other--->搜索problems就找到了，
这个所有的展示都可以在里面找到。

eclipse怎么样停止程序的运行？
可以用下面的两种方法结束运行：
1、点击下面控制台那里有个红色的四方形的按钮(关闭当前控制台)
2、点击红色方块后面的XX也可以(关闭所有的终端控制台)
ps：vs中也有红色的四方形的按钮(左上角)，是停止调试的意思

console总共有以下几个图标：
1）Terminate：停止当前执行线程
2）Remove Launch：删除当前的面板(非停止状态不可用)
3）Remove All Terminated Launches：删除所有停止状态的面板
4）Clear Console：清空当前控制台
5）Scroll Lock：锁定滚动条
6）Word Warp：控制台显示换行
7）Show Console When Standard Out Changes：当输出变更时显示在控制台
8）Show Console When Standard Error Changes：当错误变更时显示在控制台
9）Pin Console：钉住当前Console，当多个控制台的情况下，控制台有更新会自动跳到前台来，钉住后类似于置顶功能
10）Display Selected Console：选择不同的控制台
11）Open Console：打开一个新的控制台类型
其中的New Console View和原来的Console显示的内容是一样的，只是多开了一个选项卡显示



-----选中某个词后，单击右键的查看定义、转到定义、转到声明、查找所有引用功能都非常实用-----

ctrl+m：最大化当前的Edit或View(再按则反之)

ctrl+o：快速outline视图(不开Outline窗口的同学，这个快捷键是必不可少的)

alt+? 或 alt+/：自动补全代码或者提示代码
Ctrl+1 快速修复(最经典的快捷键,就不用多说了)

Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了)
Alt+↑ 当前行和上面一行交互位置(同上)
Alt+← 前一个编辑的页面
Alt+→ 下一个编辑的页面(当然是针对上面那条来说了)



eclipse中怎样设置断点和单步执行？快捷键是什么呢？
第一步：设置断点：在该行最前面边框双击(vs只需单击) 或快捷键：Ctrl+Shift+B
第二步：Debug 运行启动
第三步：
运行到断点后(快捷键太紧凑了😂)：
使用快捷键F5,F6,F7单步执行。
F5：Step into/进入该行的函数内部
F6：Step over/一行一行执行(最好)
F7：Step return/退出当前的函数
F8：到下一个断点(次好)
ctrl+r：运行至行(超好用，可以节省好多的断点)
在eclipse里面多试试就熟悉了(不如点击图标，所有编辑器都一样)
PS：6和8是偶数，5和7是奇数


eclipse中调试箭头找不到的情况下如何定位到箭头所在，不运行下一步的情况下(要不然又要从新调试)
运行下一步的情况：直接按F6就行了
不运行下一步的情况：在Debug视图中双击线程到达当前位置

eclipse 在DEBUG的时候怎么拖动箭头啊。
用VS做C#的时候，可以拖动debug箭头让程序执行上一句或者跳过几句，我觉得很方便。
但是eclipse仿佛不支持这个功能？ 请问可以做到么？
不是Eclipse不支持，是Java语言不支持这种跳过代码不执行的方式

eclipse在调试的时候怎么把箭头向上拉？
在 Eclipse 中，当你遇到断点并暂停程序时，可以通过以下方法移动调试进度之前的代码，即"把箭头向上拉"：
1. 在代码行数边栏上右键点击暂停的代码行，选择 "Run to Line"。这会使程序执行到你选择的那一行，并在那里暂停。
2. 将调试视图切换到“Debug" 视图（在工具栏的右上角找到一个类似蜘蛛网的图标，或者选择 "Window" > "Perspective" > "Open Perspective" > "Debug"）。
3. 选中 “Debug" 视图中的线程或堆栈帧，右键点击后在菜单中选择“Drop to Frame”。此操作会使程序回退到当前选中方法的开始。注意，这不能回退时间，已执行的操作是不会被还原的。
请注意，这种方法可能使程序处于无效状态，因为已执行的代码无法还原。在使用此功能的时候，谨慎操作。



按住Ctrl+鼠标左键悬停就可以实现跳转，类似于超链接

小弟想知道eclipse中有没有那种类似于转到定义或是声明的功能？
如题 就是在代码中有变量或是函数的话我点一下右键跳到变量或函数定义的地方(F3)。eclipse有没有这样的功能啊
有的，若想直接转到定义或者使用的部分，直接将光标移动到目标代码上面，然后按住ctrl键的同时左键点击目标代码就行了。

按住ctrl+鼠标移动到变量或函数处
Open Declaration(f3)：打开声明
Open Implementation(ctrl+t)：打开实现
Open Return Type：打开返回类型

Eclipse中，open declaration;open implementation;open super implementation
这三者有何区别啊？求大神指导
open declaration：是打开该方法的接口文件(一般没实在意义，只是简单一句)
open implementation：是打开具体实现该方法的类文件(具体逻辑的处理地方，方法的主要实现的地方)
open super implementation：是打开实现该方法的类文件的父文件(几乎没人用这个)
这3个都是Eclipse或者MyEclipse的在方法上按住ctrl键的快捷键



----------多键---------

ctrl+shift+f：格式化代码

ctrl+shift+r：搜索工程中的文件(默认搜索路径是MES.Env/config/bpels/CNXsvr)

ctrl+/：自动注释当前行或者选择的多行
ctrl+shift+/：自动注释掉选择的代码块

eclipse收起展开所有方法的快捷键
收缩所有方法，java、js、xml都可以：Ctrl+Shift+'/'(小键盘的‘/‘)
展开所有方法：Ctrl+Shift+'*'(小键盘的)



FIXME 后端代码



switchstart = case + otherwise
otherwise：是所有的case都不符合条件就执行这个
Case
Condition：isListEmpty('lotList')
Input Expression(value)：isListEmpty('lotList')


While = whilestart + whileend
Activity Name：while
Select a Expression type：Collection
for(iterable_type element : iterable)
Iterable variable：lotList
Element variable：lot Element








Expression
Activity Name：expression
Function：点击下面的Function List就会出现一模一样的在这儿
Function List：setVariable('lotList',getElementList('message','//LOT'));
// 从Xml中获取数据
setVariable('lotName',getXmlData('lotElement','//LOTNAME'));
setVariable('productRequestName',getXmlData('lotElement','//PRODUCTREQUESTNAME'));
// 上面是Expression获取变量，下面是Invoke Bean获取变量
getXmlData('message','//Header/EVENTCOMMENT')

-----下方是帮助文档

2) getVariable : The function to get the value of variable  
ex) getVariable('Factory') 

3) setVariable : The function to set the value of variable  
ex) setVariable('ReservedLotId', getArrayValue('Query.Result', '0', '0'))

4) getField : The function to get the field value of variable
ex) getField(getVariable('variableName'), 'fieldName'[.fieldName]*)

5) setField : The function to set the value in field of variable
ex) setField('variableName', 'fieldName'[.fieldName]*, getVariable('variableName'))








--常见的例子

No value registered for key 'LASTEVENTCOMMENT'
未定义错误信息 No value supplied for the SQL parameter 'LASTEVENTCOMMENT': No value registered for key 'LASTEVENTCOMMENT'
bindMapI.put("EVENTCOMMENT", eventInfo.getEventComment());
把上面的代码改成下面的代码就可以了：
bindMapI.put("LASTEVENTCOMMENT", eventInfo.getEventComment());

Element root = doc.getDocument().getRootElement();
Element body = root.getChild("Body");
// lotList.get(0)的数据是5S1123K0008，其他均无数据(size=1)
// LOTLIST和LOTNAME都是xml中body的标签
// 函数makeList用于获得xml中标签LOTLIST中的所有LOTNAME
List<String> lotList = CommonUtil.makeList(body, "LOTLIST", "LOTNAME");
// check Lot State And Lot Hold State By Lot List：通过LotList检查LotState和LotHoldState
List<Lot> returnLotList = CommonValidation.checkLotStateAndLotHoldStateByLotList(lotList);
return returnLotList;

// Map：行
// List：列
// 和select * from table很像
List<String> operationList = new ArrayList<String>();
// public String STEP_OEM_BOXING = "C930-00";
operationList.add(GenericServiceProxy.getConstantMap().STEP_OEM_BOXING);
// public String STEP_OEM_PALLETIZING = "C940-00";
operationList.add(GenericServiceProxy.getConstantMap().STEP_OEM_PALLETIZING);
// public String STEP_OEM_SHIPPING = "CA00-00";
operationList.add(GenericServiceProxy.getConstantMap().STEP_OEM_SHIPPING);
// contains()方法用于判断字符串中是否包含指定的字符或字符串
if( !StringUtils.isEmpty(lotData.getProcessGroupName()) && operationList.contains(lotData.getProcessOperationName()) ){
    // SPEC-1005：LOT[{0}]已分配到DENSEBOX[{1}]里了
    throw new CustomException("SPEC-1005", lotData.getKey().getLotName(), lotData.getProcessGroupName());
}
// 表processoperationspec中都没有这些站点了C930-00/C940-00/CA00-00😂










--Transaction

// rollback Transaction：回滚事务(对应plsql中的rollback按钮)
CommonUtil.rollbackTransaction();
// 下面和上面代码等价
public static void commitTransaction()
{
    IDMFrameServiceProxy.getTxDataSourceManager().commitTransaction();
}

// begin Transaction：开始事务(对应plsql中的execute按钮)
CommonUtil.beginTransaction();
// 下面和上面代码等价
public static void beginTransaction()
{
    IDMFrameServiceProxy.getTxDataSourceManager().beginTransaction();
}

// commit Transaction：提交事务(对应plsql中的commit按钮)
CommonUtil.commitTransaction();
// 上下等价，写法不同
public static void commitTransaction()
{
    IDMFrameServiceProxy.getTxDataSourceManager().commitTransaction();
}










--Invoke Bean

setProductUSequence：product

autoChangePanelGrade：bsngpanelinfo+bsqtypepanelinfo

DeassignCarrierScrapProduct：取消分配carrier(报废的product)
String upSql = "UPDATE PRODUCT " + 
                "   SET CARRIERNAME = '' " +
                " WHERE LOTNAME = :lotName AND CARRIERNAME = :carrierName";
Map<String, String> upBindMap = new HashMap<String, String>();
upBindMap.put("lotName", lotData.getKey().getLotName());
upBindMap.put("carrierName", durableData.getKey().getDurableName());
// upSql中的字符串是update语句
IDMFrameServiceProxy.getSqlTemplate().getSimpleJdbcTemplate().update(upSql, upBindMap);
log.info("Scrap Product deasssingCarrier");











--getXXXData

// select * from durable where durablename = :durablename
public Durable getDurableData(String durableName) throws FrameworkErrorSignal, NotFoundSignal, CustomException
{
    try{
        DurableKey durableKey = new DurableKey();
        durableKey.setDurableName(durableName);
        Durable durableData = null;
        durableData = DurableServiceProxy.getDurableService().selectByKey(durableKey);

        return durableData;
    } catch ( Exception e ){
        throw new CustomException("DURABLE-9006", durableName);
    }
}

// select * from lot where lotname = :lotname
// 此方法获取到了一个变量lotName
public Lot getLotData(String lotName) throws FrameworkErrorSignal, NotFoundSignal, CustomException {
    try {
        // private String lotName;
        // 类LotKey中定义了一个变量lotName，也就是说这个类是为了获取lotName
        LotKey lotKey = new LotKey();
        // lotKey.getLotName(lotName);
        lotKey.setLotName(lotName);
        // 通过调用此方法获取到表lot中的一行记录
        // Lot服务代理.获取Lot服务().通过Key选择(lotKey)
        Lot lotData = LotServiceProxy.getLotService().selectByKey(lotKey);

        return lotData;

    } catch (Exception e) {
        // 不存在的 Lot id : [{0}]
        throw new CustomException("LOT-9000", lotName);
    }
}









--check

public static void checkDurableHoldState(Durable durableData) throws CustomException {
    String durableHoldState = durableData.getDurableHoldState().toString();
    if (durableHoldState.equals(GenericServiceProxy.getConstantMap().DURABLE_HOLDSTATE_Y)) 
    {
        // DURABLE-9003：此耐用品 [{0}] 已 Holded
        throw new CustomException("DURABLE-9003", durableData.getKey().getDurableName().toString());
    }
}

public static void checkEmptyCst( String carrierName ) throws CustomException
{
    Durable durableData = CommonUtil.getDurableInfo(carrierName);
    if (StringUtils.equals(durableData.getDurableState(), GenericServiceProxy.getConstantMap().CARRIER_STATE_FULL))
    {
        // CARRIER-9001：Carrier[{0}]已被绑定
        throw new CustomException("CARRIER-9001", carrierName);
    }
}

// check Lot State：检查lot状态
public static void checkLotState(Lot lotData) throws CustomException{
    // public String Lot_Released = "Released";
    // 将当前表lot中的字段lotstate和获取到的常量Lot_Released进行比较
    if ( !StringUtils.equals(lotData.getLotState(), GenericServiceProxy.getConstantMap().Lot_Released) )
    {
        // LOT-9001：Lot[{0}]状态为已是释放状态.当前状态 : [{1}]
        throw new CustomException("LOT-9001", lotData.getKey().getLotName(), lotData.getLotState());
    }
}









--get data

// 通过表lot中的一行记录获得字段lotname中的数据
String lotName = lotData.getKey().getLotName();

// 上下两行代码的效果正好相反

Lot lotData = CommonUtil.getLotInfoByLotName(lotName);

// 上下可以对比观察，两者效果相同(下面代码多了lotKey)

// 通过lotName查看表lot的一行记录
LotKey lotKey = new LotKey(lotName);
Lot lotData = LotServiceProxy.getLotService().selectByKey(lotKey);

// 获得这个lotname中的所有productname
// select productname from product where lotname = :lotname
List<Product> productList = ProductServiceProxy.getProductService().allProductsByLot(lotData.getKey().getLotName());

// 上下可以对比观察，两者效果相同(下面代码多了键)

// select productname from product where lotname = :lotname
List<Map<String,Object>> productDataList = CommonUtil.getProductByLotName(lotName);

// 通过palletname获得一行记录
// select * from  processgroup where processgroup = :processgroup 
ProcessGroup processData = CommonUtil.getProcessGroupByProcesessGroupName(palletName);

// 通过productname获得这行product的一行记录
// select * from product where productname = :productname
Product productData = CommonUtil.getProductByProductName(sqlResultQ.get(i).get("PRODUCTNAME").toString());

// 多重引用
String lotName = root.getChild("Body").getChildText("LOTNAME");
String carrierName = root.getChild("Body").getChildText("CARRIERNAME");












--setEvent/setProductUSequence

// setEventName ≠ setEvent
// setEventName就是给字段eventname赋值
eventInfo.setEventName("ChangePanelGrade");

// throws后面报错有封装
// 函数setEvent是抽象函数
public abstract Product setEvent(ProductKey paramProductKey, EventInfo paramEventInfo, SetEventInfo paramSetEventInfo)
throws InvalidStateTransitionSignal, FrameworkErrorSignal, NotFoundSignal, DuplicateNameSignal;

// FIELD是一个类
public static class FIELD 
{
    public static String areaName = "areaName";
    public static String carrierName = "carrierName";
}

// get Constant Map：获取常量映射
public static ConstantMap getConstantMap() 
{
    return (ConstantMap) ac.getBean("ntConstantMap");
}

// 更新表lot中的数据
Lot lotData = CommonUtil.getLotInfoByLotName(lotName);
com.cim.idm.mespackage.lot.management.info.SetEventInfo setEventInfo = new 
com.cim.idm.mespackage.lot.management.info.SetEventInfo();
// 上下代码是等价的(SetEventInfo.class)
SetEventInfo setEventInfo =new SetEventInfo();
// 定义Map，将键和值都导入Map中(键和值都是新的)
Map<String, String> lotUserColumns =  new HashMap<String, String>();
lotUserColumns.put(Lot.FIELD.lotHoldState, GenericServiceProxy.getConstantMap().LOT_ONHOLD);
lotUserColumns.put(Lot.FIELD.reasonCodeType, eventInfo.getReasonCodeType());
lotUserColumns.put(Lot.FIELD.reasonCode, eventInfo.getReasonCode());
setEventInfo.setUserColumns(lotUserColumns);
// setEvent - Lot，将lot这行记录中的字段进行修改
LotServiceProxy.getLotService().setEvent(lotData.getKey(), eventInfo, setEventInfo);

// 上下代码对比查看，之所以lot用函数setEvent，product用函数setProductUSequence，是因为表lot只有一行记录，表product有多行记录

// 更新表product中的字段
// List<ProductU>可以看成一个数组
// 将productList中的字段修改成userColumns中的值
List<ProductU> productUSequence = new ArrayList<ProductU>();
com.cim.idm.mespackage.lot.management.info.SetEventInfo setEventInfo = new 
com.cim.idm.mespackage.lot.management.info.SetEventInfo();
for (int i =0;i<sqlResultQ.size();i++)
{
    ProductU productU = new ProductU();
    Map<String,String> userColumns = new HashMap<String,String>();
    userColumns.put(Product.FIELD.factoryName, "ENIG");
    userColumns.put(Product.FIELD.productSpecName, productSpecName);
    userColumns.put(Product.FIELD.productState,"InProduction" );
    userColumns.put(Product.FIELD.productProcessState,"Idle" );
    userColumns.put(Product.FIELD.productHoldState,"N" );
    userColumns.put(Product.FIELD.processFlowName, processFlowName);
    userColumns.put(Product.FIELD.productRequestName,productRequestName);
    userColumns.put(Product.FIELD.processOperationName,processOperationName);
    userColumns.put(Product.FIELD.sequenceId, sequenceId);
    userColumns.put(Product.FIELD.destinationFactoryName, "");
    Product productData = CommonUtil.getProductByProductName(sqlResultQ.get(i).get("PRODUCTNAME").toString());
    userColumns.put(Product.FIELD.arrayShipSubGrades, productData.getSubProductGrades());
    userColumns.put(Product.FIELD.cfShipSubGrades, productData.getSubProductDetailGrade());
    productU.setUserColumns(userColumns);
    // 给类productU中的变量PRODUCTNAME赋值
    String productName = sqlResultQ.get(i).get("PRODUCTNAME").toString();
    productU.setProductName(productName);
    // 上下代码是等价的
    productU.setProductName(sqlResultQ.get(i).get("PRODUCTNAME").toString());
    productUSequence.add(productU);
}
// update product set factoryname=ENIG,productSpecName=:productSpecName where productname=:productname
setEventInfo.setProductUSequence(productUSequence);
log.info("Update Product Success!");

// PRODUCTLIST和PRODUCTNAME都是xml中body的标签
// 函数makeList用于获得xml中标签PRODUCTLIST中的所有PRODUCTNAME
List<String> productList = CommonUtil.makeList(body, "PRODUCTLIST", "PRODUCTNAME");
// get Constant Map：获取常量映射
// 定义Map，将键和值都导入Map中(键和值都是新的)
Map<String, String> userColumns = new HashMap<String, String>();
// public String Lot_Completed = "Completed";
userColumns.put(Lot.FIELD.lotState, GenericServiceProxy.getConstantMap().Lot_Completed);
// public String Prod_Completed = "Completed";
userColumns.put(Product.FIELD.productState, GenericServiceProxy.getConstantMap().Prod_Completed);
// public String ETCFLAG_OUT = "OUT";
userColumns.put(Lot.FIELD.etcFlag, GenericServiceProxy.getConstantMap().ETCFLAG_OUT);
userColumns.put(Lot.FIELD.departmentCode, departmentCode);
userColumns.put(Lot.FIELD.etcReturnFlag, etcReturnFlag);
userColumns.put(Lot.FIELD.carrierName,"");
// List<ProductU>可以看成一个数组
// 将productList中的字段修改成userColumns中的值
List<ProductU> productUSequence = LotServiceUtil.setProductUSequenceByProductList(productList, userColumns);
// 将整个List的字段etcflag修改成ETCOut(ETC是领入/领出的意思)
eventInfo.setEventName("ETCOut");
for (int i = 0;i<lotList.size();i++)
{
    Lot lotData1 = CommonUtil.getLotInfoByLotName(lotList.get(i));
    setEvent(eventInfo, lotData1.getKey().getLotName(), userColumns, productUSequence);
}












--getSimpleJdbcTemplate

// BindMask.java中每个函数增删改查一个sql表

Element root = doc.getDocument().getRootElement();
// Body和DURABLELIST都是xml中的标签
Element body = root.getChild("Body");
Element durableElement = body.getChild("DURABLELIST"); // DURABLELIST的路径是MES.Common→Entities→DURABLELIST.cs

// 上下可以对比观察

// CONSUMABLELIST/CONSUMABLESPECLIST/INSPECTFLAG都是xml格式的标签
Element root = doc.getDocument().getRootElement();
Element body = root.getChild("Body");
Element element = body.getChild("CONSUMABLELIST");
Element listElement = body.getChild("CONSUMABLESPECLIST");
String flag =body.getChild("INSPECTFLAG").getText();// 后端数据有空的，不能getText()，不然会报错


String sql = "SELECT PRODUCTNAME FROM PRODUCT WHERE LOTNAME = :LOTNAME";
Map<String,Object> bindMap = new HashMap<String,Object>();
bindMap.put("LOTNAME", lotData.getKey().getLotName());
// 有点像vs中的一段代码
// Collection<PRODUCTSPEC> ProductSpecList = factoryService.GetProductSpecList(new PRODUCTSPEC() { FACTORYNAME = ConnectionInfo.FactoryName }, "30001");
List<Map<String,Object>> sqlResult = IDMFrameServiceProxy.getSqlTemplate().getSimpleJdbcTemplate().queryForList(sql, bindMap);

// 上面是查询代码，下面是更新代码

String sqlI = " INSERT INTO BSPRODUCTMASKINFO(PRODUCTSPECNAME, LOTTYPE,PROCESSOPERATIONNAME, DURABLENAME,EVENTNAME,EVENTTIMEKEY,EVENTUSER,EVENTCOMMENT) "+ " VALUES(:PRODUCTSPECNAME,:LOTTYPE, :PROCESSOPERATIONNAME, :DURABLENAME , :EVENTNAME, :EVENTTIMEKEY, :EVENTUSER,:EVENTCOMMENT)";

// 上下对比观察，sql一次性写完和用append追加是等价的

log.info("Check Whether need Update BsMicroExamInfo...");
// 当操作是镜检的时候，会更新sql中某些字段的信息
if(actionFlag.equals("MicroExam"))
{
    log.info("Need Update, Start...");
    // 使用append的时候需要数据类型StringBuilder
    // 和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象
    StringBuilder sql = new StringBuilder();
    sql.append("UPDATE BSMICROEXAMINFO");
    sql.append("   SET ENDTIME      = :ENDTIME,");
    sql.append("       ENDUSER      = :ENDUSER,");
    sql.append("       ENDEVENTNAME = :ENDEVENTNAME");
    sql.append(" WHERE LOTNAME = :LOTNAME");
    sql.append(" AND ENDTIME IS NULL");
    Map<String,Object> bindMap = new HashMap<String,Object>();
    bindMap.put("ENDTIME", eventInfo.getEventTime());
    bindMap.put("ENDUSER", eventInfo.getEventUser());
    bindMap.put("ENDEVENTNAME", eventInfo.getEventName());
    bindMap.put("LOTNAME", lotName);
    IDMFrameServiceProxy.getSqlTemplate().getSimpleJdbcTemplate().update(sql.toString(), bindMap);
    log.info("Update BsMicroExamInfo Successfully!");
}

// 上下都是更新sql字段

// 方法update执行insert和update都可以
Element body = doc.getRootElement().getChild("Body");
String sql = "";
Map<String,String> udf = new HashMap<String,String>(); 
String productSpecName = body.getChildText("PRODUCTSPECNAME");
String possibleProductSpecName = body.getChildText("POSSIBLEPRODUCTSPECNAME");
String productionType = body.getChildText("PRODUCTIONTYPE");
String receiveFactoryName = body.getChildText("RECEIVEFACTORYNAME");
String qType = body.getChildText("QTYPE");
udf.put("CONDITIONID", productSpecName);
udf.put("POSSIBLEPRODUCTSPECNAME", possibleProductSpecName);
udf.put("PRODUCTIONTYPE", productionType);
udf.put("RECEIVEFACTORYNAME", receiveFactoryName);
udf.put("QTYPE", qType);
String sqlDE = "DELETE FROM POSRECEIVEPRODUCTSPEC WHERE CONDITIONID = :CONDITIONID AND  RECEIVEFACTORYNAME=:RECEIVEFACTORYNAME AND " + "POSSIBLEPRODUCTSPECNAME = :POSSIBLEPRODUCTSPECNAME AND PRODUCTIONTYPE = :PRODUCTIONTYPE AND QTYPE= :QTYPE";
IDMFrameServiceProxy.getSqlTemplate().getSimpleJdbcTemplate().update(sqlDE, udf);
sql = "INSERT INTO POSRECEIVEPRODUCTSPEC (CONDITIONID,RECEIVEFACTORYNAME,POSSIBLEPRODUCTSPECNAME,PRODUCTIONTYPE,QTYPE ) " +
"VALUES (:CONDITIONID, :RECEIVEFACTORYNAME, :POSSIBLEPRODUCTSPECNAME, :PRODUCTIONTYPE, :QTYPE )";
IDMFrameServiceProxy.getSqlTemplate().getSimpleJdbcTemplate().update(sql, udf);

// 下面和上面代码等价，但是update语句只有一个变量，上面有两个变量

ProcessGroup processData = new ProcessGroup();
processData = CommonUtil.getProcessGroupByProcesessGroupName(palletName);
processData.setFactoryName("ENIG");
processData.setProductSpecName(productSpecName);
processData.setReceiveFlag("Y");
processData.setReceiveTimeKey(eventInfo.getEventTimeKey());
processData.setLastEventName(eventInfo.getEventName());
processData.setLastEventTime(eventInfo.getEventTime());
processData.setLastEventTimeKey(eventInfo.getEventTimeKey());
processData.setLastEventUser(eventInfo.getEventUser());
processData.setLastEventComment(eventInfo.getEventComment());
// 直接将更新的数据同步到数据库
ProcessGroupServiceProxy.getProcessGroupService().update(processData);
log.info("Update ProcessGroup Successfully!");













--前后端交互的例子

// vs发送数据
Collection<PROCESSGROUP> colPallet = new Collection<PROCESSGROUP>();
foreach (UltraGridRow row in this.grdPalletList.Rows)
{
    if (Convert.ToBoolean(row.Cells["CHECK"].Value))
    {
        PROCESSGROUP obj = new PROCESSGROUP();
        obj.PALLETNAME = row.Cells["PROCESSGROUPNAME"].Text;
        obj.FGCODE = row.Cells["FGCODE"].Text;
        obj.MATERIALQUANTITY = row.Cells["MATERIALQUANTITY"].Text;
        colPallet.Add(obj);
    }
}
PROCESSGROUP objPallet = new PROCESSGROUP();
objPallet.PRODUCTREQUESTNAME = cmbTargetBatchName.Text;
objPallet.PRODUCTIONTYPE = txtTargetProductionType.Text;
objPallet.PRODUCTSPECNAME = cmbProductSpecName.Text;
userCommand.SetUserComment(userCommand.txtComment.Text);
if (new FactoryService().SetEvent(UDFCONST.ReceiveENIGFromSensor, objPallet, colPallet))
{
    btnView_Click(null, null);
}

//  eclipse接收数据
public static void ReceiveENIGFromSensor( Document doc, EventInfo eventInfo) throws CustomException, Exception {
    Map<String, Object> bindMap = new HashMap<String, Object>();
    Map<String, Object> bindMapF = new HashMap<String, Object>();
    List<Map<String, Object>> sqlResult = new ArrayList<Map<String, Object>>();
    Element body = doc.getRootElement().getChild("Body");
    Element listElement = body.getChild("PROCESSGROUPLIST");
    String productSpecName = body.getChild("PRODUCTSPECNAME").getText();
    String productRequestName = body.getChildText("PRODUCTREQUESTNAME");


    for(Iterator<?> iterator = listElement.getChildren().iterator();iterator.hasNext();)
    {
        Element processGroup = (Element) iterator.next();
        String palletName = processGroup.getChild("PALLETNAME").getText();
        //String fgcode = processGroup.getChild("FGCODE").getText();
        //String materialQuantity =  processGroup.getChild("MATERIALQUANTITY").getText();
        //get flow and operationName
        String sqlFlow = "SELECT * FROM PROCESSFLOWSEQ WHERE PROCESSFLOWNAME IN " +
                    "(SELECT PROCESSFLOWNAME FROM PRODUCTSPEC WHERE PRODUCTSPECNAME = :productSpecName) AND POSITION ='1'";
        bindMapF.put("productSpecName", productSpecName);
        // 获得Q段第一个站点的所有信息
        List<Map<String, Object>> sqlResultF = IDMFrameServiceProxy.getSqlTemplate().getSimpleJdbcTemplate().queryForList(sqlFlow, bindMapF);
        if (sqlResultF.size()<0 || sqlResultF.size()>1)
        {   // PROCESSFLOW-9005：未找到返回的Flow和站点信息
            throw new CustomException("PROCESSFLOW-9005" );
        }
        // 只有一行记录
        String processFlowName = sqlResultF.get(0).get("PROCESSFLOWNAME").toString();
        String processOperationName = sqlResultF.get(0).get("PROCESSOPERATIONNAME").toString();
        String sequenceId = sqlResultF.get(0).get("SEQUENCEID").toString();
        //IDMFrameServiceProxy.getTxDataSourceManager().beginTransaction();
        //Get Glass Info By PalletID
        String sqlQ = "SELECT PRODUCTNAME FROM PRODUCT WHERE PROCESSGROUPNAME IN (:PALLETNAME)";
        String sqlL = "SELECT LOTNAME,PRODUCTREQUESTNAME FROM LOT WHERE PROCESSGROUPNAME IN (:PALLETNAME)";
        Map<String,String> bindMapQ = new HashMap<String,String>();
        bindMapQ.put("PALLETNAME", palletName);
        List<Map<String, Object>> sqlResultQ = IDMFrameServiceProxy.getSqlTemplate().getSimpleJdbcTemplate().queryForList(sqlQ, bindMapQ);
        List<Map<String, Object>> sqlResultL = IDMFrameServiceProxy.getSqlTemplate().getSimpleJdbcTemplate().queryForList(sqlL, bindMapQ);
        if(sqlResultQ == null || sqlResultQ.size() == 0)
        {
            throw new CustomException("PRODUCT-9056", "");
        }
        
        String ProductRequestNameOld = sqlResultL.get(0).get("PRODUCTREQUESTNAME").toString();
        List<ProductU> productUSequence = new ArrayList<ProductU>();
        com.cim.idm.mespackage.lot.management.info.SetEventInfo setEventInfo = new com.cim.idm.mespackage.lot.management.info.SetEventInfo();
        
            for (int i =0;i<sqlResultQ.size();i++)
            {
                String productName = sqlResultQ.get(i).get("PRODUCTNAME").toString();
                //ProcessGroupService.updateProduct(productName);
                ProductU productU = new ProductU();
                Map<String,String>userColumns= new HashMap<String,String>();
                userColumns.put(Product.FIELD.factoryName, "ENIG");
                userColumns.put(Product.FIELD.productSpecName, productSpecName);
                userColumns.put(Product.FIELD.productState,"InProduction" );
                userColumns.put(Product.FIELD.productProcessState,"Idle" );
                userColumns.put(Product.FIELD.productHoldState,"N" );
                userColumns.put(Product.FIELD.processFlowName, processFlowName);
                userColumns.put(Product.FIELD.productRequestName,productRequestName);
                userColumns.put(Product.FIELD.processOperationName,processOperationName);
                userColumns.put(Product.FIELD.sequenceId, sequenceId);
                userColumns.put(Product.FIELD.destinationFactoryName, "");
                Product productData = CommonUtil.getProductByProductName(sqlResultQ.get(i).get("PRODUCTNAME").toString());
                userColumns.put(Product.FIELD.arrayShipSubGrades, productData.getSubProductGrades());
                userColumns.put(Product.FIELD.cfShipSubGrades, productData.getSubProductDetailGrade());
                productU.setUserColumns(userColumns);
                productU.setProductName(sqlResultQ.get(i).get("PRODUCTNAME").toString());
//						Product productData = CommonUtil.getProductByProductName(sqlResultQ.get(i).get("PRODUCTNAME").toString());
                productUSequence.add(productU);
            }

            setEventInfo.setProductUSequence(productUSequence);
            log.info("Update Product Success!");
            Map<String,String>userColumnsLot = new HashMap<String,String>();
            LotKey lotKey = new LotKey();
            lotKey.setLotName(sqlResultL.get(0).get("LOTNAME").toString());
            Lot lotData = CommonUtil.getLotInfoByLotName(sqlResultL.get(0).get("LOTNAME").toString());
            userColumnsLot.put(Lot.FIELD.productSpecName, productSpecName);
            userColumnsLot.put(Lot.FIELD.productRequestName, productRequestName);
            userColumnsLot.put(Lot.FIELD.factoryName, "ENIG");
            userColumnsLot.put(Lot.FIELD.areaName, "EBAY01");
            userColumnsLot.put(Lot.FIELD.lotState, "Released");
            userColumnsLot.put(Lot.FIELD.lotProcessState, "WAIT");
            userColumnsLot.put(Lot.FIELD.lotHoldState, "N");
            userColumnsLot.put(Lot.FIELD.processFlowName, processFlowName);
            userColumnsLot.put(Lot.FIELD.processOperationName, processOperationName);
            userColumnsLot.put(Lot.FIELD.sequenceId, sequenceId);
            userColumnsLot.put(Lot.FIELD.receivedFlag, "");
            userColumnsLot.put(Lot.FIELD.destinationFactoryName, "");
            userColumnsLot.put(Lot.FIELD.initialCreateType, ProductRequestNameOld);
            setEventInfo.setUserColumns(userColumnsLot);
            setEventInfo.setProductQuantity(sqlResultQ.size());
            LotServiceProxy.getLotService().setEvent(lotData.getKey(), eventInfo, setEventInfo);
            log.info("Update Lot and Product Info Successfully!");
            
            //Update Box

            ProcessGroup processData = new ProcessGroup();
            processData = CommonUtil.getProcessGroupByProcesessGroupName(palletName);
            processData.setFactoryName("ENIG");
            processData.setProductSpecName(productSpecName);
            processData.setReceiveFlag("Y");
//					processData.setProductionInput("");
            processData.setReceiveTimeKey(eventInfo.getEventTimeKey());
            processData.setLastEventName(eventInfo.getEventName());
            processData.setLastEventTime(eventInfo.getEventTime());
            processData.setLastEventTimeKey(eventInfo.getEventTimeKey());
            processData.setLastEventUser(eventInfo.getEventUser());
            processData.setLastEventComment(eventInfo.getEventComment());
            ProcessGroupServiceProxy.getProcessGroupService().update(processData);
            log.info("Update ProcessGroup Successfully!");
            processData = CommonUtil.getProcessGroupByProcesessGroupName(palletName);
            String sqlI = "INSERT INTO PROCESSGROUPHISTORY (PROCESSGROUPNAME, TIMEKEY, EVENTTIME, EVENTNAME, SUPERPROCESSGROUPNAME, OLDMATERIALQUANTITY, MATERIALQUANTITY, " +
                    "EVENTUSER, EVENTCOMMENT, EVENTFLAG, REASONCODETYPE,REASONCODE, PRODUCTSPECNAME, QTYPEYN, FACTORYNAME, SHIPFLAG, SHIPDESTINATION, RECEIVETIMEKEY, " +
                    "RECEIVEFLAG, OQALOTNAME, FGCODE, OQADENSEBOXRESULT, OQABOXRESULT, OQAPALLETRESULT, SALEDESTINATION, OQALOTRESULT, SHIPPINGTYPE, PRODUCTIONINPUT, " +
                    "RETURNFLAG, WOODID, GROUPNAME) " +
                    "VALUES (:PROCESSGROUPNAME, :TIMEKEY, :EVENTTIME, :EVENTNAME, :SUPERPROCESSGROUPNAME, :OLDMATERIALQUANTITY, :MATERIALQUANTITY,:EVENTUSER," +
                    ":EVENTCOMMENT, :EVENTFLAG, :REASONCODETYPE, :REASONCODE,:PRODUCTSPECNAME, :QTYPEYN,:FACTORYNAME, :SHIPFLAG, :SHIPDESTINATION, " +
                    ":RECEIVETIMEKEY, 	:RECEIVEFLAG, :OQALOTNAME, :FGCODE, :OQADENSEBOXRESULT, :OQABOXRESULT, 	:OQAPALLETRESULT, :SALEDESTINATION, :OQALOTRESULT, " +
                    ":SHIPPINGTYPE, :PRODUCTIONINPUT, :RETURNFLAG, :WOODID, :GROUPNAME )";
            
            Map<String,Object>insertPro = new HashMap<String,Object>();
            insertPro.put("PROCESSGROUPNAME",palletName);
            insertPro.put("SUPERPROCESSGROUPNAME","");
            insertPro.put("EVENTCOMMENT",eventInfo.getEventComment());
            insertPro.put("PRODUCTSPECNAME",productSpecName);
            insertPro.put("FACTORYNAME","ENIG");
            insertPro.put("SHIPFLAG",processData.getShipFlag());
            insertPro.put("RECEIVEFLAG","Y");

            insertPro.put("GROUPNAME",processData.getGroupName());
            IDMFrameServiceProxy.getSqlTemplate().getSimpleJdbcTemplate().update(sqlI, insertPro);
            log.info("Insert into ProcessGroupHistory Successfully!");

            //CommonUtil.commitTransaction();
            log.info("Receive Success!");
        }
}




TODO 后端发布

eclipse publish + server publish

packaging-build.xml是Ant自动构建的

后端发布和前端一样，先update再commit

问题：无法点进code，需重新发布bpel(发布之前确认)

--MES.Env→builders
PROD01/PROD02：两个服务器
commons-net-ftp-2.0.jar：ftp实现文件的上传下载
packaging-allBundle-build.xml：打包所有Bundle build xml






--bpel和代码分别打包(PROD01/PROD02重复两遍)

代码打包：MES.Env→builders→DEV→upload_target_Custom_DEV.xml
替换1行代码：<include name="target.boe.bundles/*.jar" />
run as → Ant Build(选第1个)

bpel打包：MES.Env→builders→DEV→upload_bpels_DEV_CNX.xml
替换1行代码(只替换名字)：<include name="config/bpels/CNXsvr/*.bpel" />
run as → Ant Build(选第1个)

提交：upload_target_MES_Backup_DEV_PROD01.xml
run as → Ant Build(选第1个)

建立：MES.Env→builders→packaging-allBundle-build.xml
run as → Ant Build(选第1个)







--依此类推

upload_actions_DEV.xml：给*.adf文件打包
替换1行代码：<include name="config/actions/*.adf" />
run as → Ant Build(选第1个)

upload_cfg_DEV.xml：给*.ini文件打包
替换1行代码：<include name="cfg/**/*.ini" />
run as → Ant Build(选第1个)

upload_log4j_DEV.xml：给log4j.xml文件打包
替换1行代码：<include name="config/log/log4j.xml" />
run as → Ant Build(选第1个)

upload_target_All_LIBs.xml：给*.jar文件打包
替换1行代码：<include name="target.boe.bundles/*.jar" />
run as → Ant Build(选第1个)

upload_target_MES_Backup_DEV.xml：回退打包
run as → Ant Build(选第1个)
upload_target_MES_Recovery_DEV.xml：恢复打包
run as → Ant Build(选第1个)
upload_target_MESSolutions_DEV.xml：解决方案打包
run as → Ant Build(选第1个)








--server publish

--PROD01/PROD02两个服务器分别重启(不能同时关闭)
cs status all
cs stop CNM
cs stop CNX
cs start CNM
cs start CNX



在idmframe.esb.tiboco.xml中配置





TODO vscode

自动保存：file -> AutoSave(中文界面下“文件”->“自动保存”)或者 ctrl+Shift+P，输入 auto

--按esc取消智能提示(其实大部分按键都可以实现)
visual studio code智能提示：按住tab表示确定(与输入汉字时的space类似)     -----默认情况下，Tab 或 Enter 是接受键盘触发器

-----下面的快捷键都可以通过点击实现-----

打开终端：Ctrl + `

ctrl+shift+v/点击预览：预览markdown

ctrl+b(bar)：显示或隐藏左侧目录栏，也就是文件资源管理器。这个快捷键可以方便地在编辑区和目录栏之间切换，节省空间和时间

ctrl+p：搜索文件(everything)
ctrl+shit+f＞ctrl+f：全局搜索，就是左边的搜索，但是和输入法冲突了，巨坑啊(bb doc)

查找 ctrl+f
查找替换 ctrl+H
跳转到某行 ctrl+G

ctrl+/ 注释
ctrl+d：下一个匹配的也被选中
ctrl+backspace：删除上一个词
shift+alt：竖行编辑(在一个长方体内编辑)
shift+tab: 与 tab 的效果相反(发现shift是递归的)
ctrl+shift+l：同时选中所有匹配编辑(与当前行或选定内容匹配)

vscode行编辑，当光标停在某一行(不用选中该行)：
复制整行：Ctrl + C
剪切整行：Ctrl + X(不需要按ctrl+l)
粘贴整行：Ctrl + V
全选整行：Ctrl + L(重复则选中下一行代码) --vs中是删除整行

移动到行首：Home
移动到行尾：End
移动到文件结尾：ctrl+End
移动到文件开头：ctrl+Home
从光标到行尾的内容：Shift+End
从光标到行首的内容：Shift+Home

f1 或 ctrl+Shift+P(俗称万能键)：打开命令面板。在打开的输入框内，可以输入任何命令

f11：全屏显示(再次按则恢复)
f8：跳转到下一个Error或Warning：当有多个错误时可以按f8逐个跳转

f12：移动到定义处
shift+f12：找到所有的引用示例：选中foo()函数,然后按住快捷键「Shift + f12」，就能看到 foo()函数在哪些地方被调用了，比较实用

f2：比如要修改一个方法名，可以选中后按f2，输入新的名字，回车，会发现所有的文件都修改过了(f2改变量/函数名，不改定义)
ctrl+f2：同时修改本文件中所有匹配的

ctrl + KZ 禅模式：注意这里的禅模式的按法是按下 ctrl + K (二者一起按下去) ，之后都松开，然后按一下Z就行了(英文模式)，连按两下ESc退出禅模式



----------多键---------

vscode花括号跳转(快捷键)
Mac Cmd + Shift+\
Windows Ctrl + Shift+\

vscode中ctrl+shift+p是啥意思？ 
ctrl+shift+p其实就是调出用于执行命令的输入框，这些命令来自VSCode自带已经插件扩展的命令。
PS：Ctrl + Shift + P = F1 	显示命令面板 Show Command Palette

格式化：Shift键 + Alt键 + f键
请问代码格式化有什么作用？？？？？
代码格式化，主要是整理原代码的缩进，以及运算符的间隔等
目的是使代码缩进清晰，更容易阅读

VSCode 代码块/全文折叠/展开快捷键
常用的两类场景(注意要操作的范围)：
要操作光标所在文件中的所有代码块：
折叠所有 Ctrl+K+0
展开所有 Ctrl+K+J
仅仅操作光标所处代码块内的代码：
折叠 Ctrl+Shift+[
展开 Ctrl+Shift+]

---鼠标放在图标上会显示快捷方式---
ctrl+Shift+E：显示资源管理器
ctrl+Shift+f：显示搜索
ctrl+Shift+D：显示 Debug
ctrl+shift+g：显示git
ctrl+Shift+U：显示 Output
ctrl+Shift+Y：打开调试控制台



----------下面是解决问题----------

console有些细节的东西没法看到,debug的好处就是可以直接到断点看具体细节,包括函数内部的互相跳转,整个运转流程,不是一个量级的

卸载前端扩展后，!+tab竟然又可以了
前端扩展：代码块，其实还是实现智能跟踪的

不同文件夹下可以存在相同的文件名
可以直接修改后缀名，文件图像随之改变

为啥不用写图片路径？
绝对路径与相对路径
同文件夹引用不用写路径

鼠标操作：
在当前行的位置，鼠标点击，可以选中当前行
用鼠标单击文件的行号，可以选中当前行
在某个行号的位置，上下移动鼠标，可以选中多行

文件直接剪切到E:\VScode-win32-x64-1.42.1-1\VS code-workspace\project\dd.csv，或者E:\update\abnormal.txt，不加会自动创建
复制绝对路径：E:\VScode-win32-x64-1.42.1-1\VS code-workspace\project\vs code.txt
复制相对路径：project\vs code.txt



FIXME others


Bookmarks(有快捷键)和todotree功能很相似

一般用在代码比较长的情况下，可以快速找到某段代码的位置。
说白了就是标记，顾名思义，看书里某页处放个书签，就是起标记作用的嘛！

代码添加书签/快速查找/定位
“代码添加书签,方便查阅大量代码时,快速切换需要浏览的位置和在多个项目中无缝切换;” 

可以右击书签(或者alt+b)
跳至上一个：alt+↑
跳至上一个：alt+↓
vscode原始的功能是：向上/向下移动一行
按Alt + 向上箭头当前行向上移动，按Alt + 向下箭头(Mac: option+ 向下箭头))当前行向下移动。

用visual studio阅读代码，可以使用“书签”功能（即F2、Ctrl+F2），在某行代码上做一个“书签”，下次可以方便的回来继续阅读。
eclipse有没有类似的功能和快捷键？
在左侧的标尺上右键 --> Add Bookmark....
快捷键还真不知道

Eclipse添加和查看书签
添加书签：
在编辑框左边栏右击 > Add Bookmark > 编辑书签名称（可以直接使用默认名称）> OK
查看书签：
Window > Show View > Other > 输入book字样会出现Bookmarks > OK
然后就可以在IDE的底部出现的Bookmarks视图查看和编辑所有书签了






和撤销(ctrl+z)/恢复(ctrl+y)不一样，是撤销/恢复定位

--vs--
返回上一步光标位置：ctrl+-
返回下一步光标位置：ctrl+shift+-

vscode转到定义及返回 快捷键
ctrl + 鼠标左击 跳转定义
alt + ← 返回

VSCode 返回上一个光标 (上一个浏览位置)
Ctrl + 鼠标左击跳到定义
返回: Alt + ← ;或者 鼠标侧键(返回下一个光标：Alt + →)

word中像vscode中的返回上一步
快捷键Ctrl + Alt + Z可以轻松实现返回上一步的功能(限制在三个地方)，和Shift+F5搭配使用(跳转到上次编辑的位置)
PS：在宏中使用这些命令，可以实现与快捷键相似的操作

excel中像vscode中的返回上一步快捷键是什么？
在 Excel 中，可以使用快捷键 Ctrl + Z 来撤销上一步操作。如果需要重复上一步操作，则可以使用快捷键 Ctrl + Y。

在 Word 中，撤销上一步的快捷键是 Ctrl + Z。在 Excel 里面，撤销操作的快捷键也是相同的，即 Ctrl + Z。使用这个快捷键可以方便地撤销上一步的操作。另外，Shift + F5 在 Word 中的功能是跳转到上次编辑的位置，而在 Excel 中该快捷键没有相应的功能。

如何在 Word 中快速返回到前次(光标)编辑的位置
1、“ctrl+z” 这个快捷键是退回上一步操作
2、“Shift+F5” 是将插入点返回到上次编辑的位置，Word 能够记忆前三次的编辑位置
在打开文档时如果想返回到上次编辑的地方，打开文档之后立即按 “Shift+F5” 快捷键，则光标﻿可以立即移动到上次退出 Word 时最后一次编辑的位置。

在 word 文档中跳转后如何返回到之前的位置(适用于超链接和引用)？
点开超链接或者引用标以后，按下 Alt + 左方向即可跳回之前的阅读页
这才是正确答案，别人都是答非所问
简单明了，直接解决问题，其它回答都是啥啊，扯一大篇，一点用没有








word无法全局搜索，需要第三方

Visual Studio在整个项目中查找、替换
方法：编辑->查找和替换->在整个解决方案中查找
快捷键：Ctrl+Shift+f(vscode也一样)

Eclipse全局搜索代码步骤 
1、使用快捷键“ctrl+H”打开文件搜索对话框，选择“File Search”标签，在Containing text中输入你需要搜索的字符串，在Scope中，选择你要搜索的范围(Workspace就是全局)，点击Search。 
2、在Search视图中，会列出搜索得到的结果，点击Show Next Match(Ctrl+.)跳转到下一个匹配的代码。 

vscode 解決 ctrl+shift+f 无效问题(直接在左边点击搜索图标也可以全局搜索)
1. vscode ctrl+shift+f快捷键 一直无效，查看vscode配置没问题
2. 猜想应该是和某个系统的快捷键冲突了，经过查找。发现是win10 自带的输入冲突
细化一下：打开设置页面搜语言（在首选语言界面点击“中文（简体，中国）”）→点选项→点微软拼音→点选项→点按键→把热键（ctrl+shift+f）关闭即可
搜狗拼音输入法，一样有这个问题
原来是输入法的锅






everything可以搜索所有文件😂

Eclipse全局查找文件是ctrl+shift+r

vscode在资源管理器中查找文件名：ctrl + P

如何在Visual Studio中搜索文件名？
在Eclipse中，你可以通过按项目搜索一个文件CTRL+SHIFT+R
在Visual Studio中有没有办法做到这一点？
只需点击：CTRL + ;(搜索解决方案资源管理器)
我可能每天浪费30分钟，只是在解决方案资源管理器中寻找正确的文件。这是我最喜欢的新快捷方式！
不幸的是，这不仅限于文件名搜索，还包括符号






vscode会自动打开文件路径

eclipse：Link with Editor

在VS解决方案资源管理器中自动定位当前编辑中的文件
依次点击【工具】- 【选项】 - 【项目和解决方案】-【常规】- 勾选【在解决方案资源管理器中跟踪活动项】
困惑了我好久，谢谢大佬


